package nl.tabuu.tabuucore.command;

import nl.tabuu.tabuucore.TabuuCore;
import nl.tabuu.tabuucore.command.argument.ArgumentConverter;
import nl.tabuu.tabuucore.command.argument.converter.OrderedArgumentConverter;
import nl.tabuu.tabuucore.debug.Debug;
import nl.tabuu.tabuucore.util.BukkitUtils;
import nl.tabuu.tabuucore.util.Dictionary;
import org.bukkit.Bukkit;
import org.bukkit.command.CommandExecutor;
import org.bukkit.command.CommandSender;
import org.bukkit.command.PluginCommand;
import org.bukkit.command.TabCompleter;
import org.bukkit.command.defaults.BukkitCommand;

import java.util.*;

public abstract class Command extends BukkitCommand implements CommandExecutor, TabCompleter {
    private Command _parent;
    private SenderType _requiredSenderType;
    private ArgumentConverter _argumentConverter;
    private HashMap<String, Command> _subCommandMap;

    private Dictionary _local;

    protected Command(String name){
        this(Bukkit.getPluginCommand(name));
    }

    protected Command(String name, Command parent) {
        this(Objects.requireNonNull(Bukkit.getPluginCommand(name)), parent);
    }

    protected Command(PluginCommand command){
        this(command, null);
    }

    protected Command(PluginCommand command, Command parent){
        super(command.getName());
        this.setDescription(command.getDescription());
        this.setPermission(command.getPermission());
        this.setPermissionMessage(command.getPermissionMessage());
        this.setUsage(command.getUsage());
        this.setLabel(command.getLabel());
        this.setAliases(command.getAliases());
        command.setTabCompleter(this);

        setRequiredSenderType(SenderType.ANY);
        setArgumentConverter(new OrderedArgumentConverter());

        _parent = parent;
        _subCommandMap = new HashMap<>();
        _local = TabuuCore.getInstance()
                .getConfigurationManager()
                .getConfiguration("lang")
                .getDictionary("");
    }

    /**
     * Handles the execution of the command.
     * @param sender The {@link CommandSender} who executed the command.
     * @param arguments The arguments converted based on the return of {@link #getArgumentConverter()}.
     * @return The result of the command.
     */
    protected abstract CommandResult onCommand(CommandSender sender, List<Optional<?>> arguments);

    @Override
    public boolean execute(CommandSender sender, String label, String[] arguments) {
        boolean hasArguments = arguments.length > 0;
        boolean isSubCommandRedirect = (hasArguments && _subCommandMap.containsKey(arguments[0]));

        if(isSubCommandRedirect){
            Command command = getSubCommand(arguments[0]);
            command.execute(sender, label, Arrays.copyOfRange(arguments, 1, arguments.length));
            return true;
        }

        boolean isCorrectSenderType = !hasRequiredSenderType() || getRequiredSenderType().getClassType().isInstance(sender);
        String senderTypeMessage = _local.translate("ERROR_COMMAND_INVALID_SENDER_TYPE",
                "{TYPE}", getRequiredSenderType().name());

        if(!isCorrectSenderType){
            sender.sendMessage(senderTypeMessage);
            return true;
        }

        boolean needsPermission = getPermission() != null;
        boolean hasPermission = !needsPermission || sender.hasPermission(getPermission());
        String permissionNode = needsPermission ? getPermission() : "null";
        String permissionMessage = getPermissionMessage() != null ? getPermissionMessage() :
                _local.translate("ERROR_INSUFFICIENT_PERMISSION",
                        "{PERM}", permissionNode);

        if(!hasPermission){
            sender.sendMessage(permissionMessage);
            return true;
        }

        List<Optional<?>> convertedArguments = getArgumentConverter().convertArguments(sender, arguments);
        CommandResult result = onCommand(sender, convertedArguments);

        switch (result){
            case NO_PERMISSION:
                sender.sendMessage(permissionMessage);
                return true;

            case WRONG_SYNTAX:
                sender.sendMessage(getUsage());
                return true;

            case SUCCESS:
                return true;

            default:
                return false;
        }
    }

    @Override
    public boolean onCommand(CommandSender sender, org.bukkit.command.Command bukkitCommand, String label, String[] arguments) {
        return execute(sender, bukkitCommand.getLabel(), arguments);
    }

    /**
     * Returns a list of suggestions for the argument that is being typed.
     * @param arguments A list of arguments in front of the partial argument.
     * @param partial The partial argument.
     * @param sender The sender of the suggest request.
     * @param suggestions Suggestions generated by TabuuCore.
     * @return A list of suggestions for the partial argument.
     */
    protected List<String> onTabSuggest(CommandSender sender, List<String> arguments, String partial, List<String> suggestions){
        return suggestions;
    }

    @Override
    public List<String> onTabComplete(CommandSender sender, org.bukkit.command.Command bukkitCommand, String label, String[] arguments) {
        boolean hasPartialArgument = arguments.length > 0;
        boolean hasWholeArgument = arguments.length > 1;

        if(!hasPartialArgument)
            return Collections.emptyList();

        boolean isSubCommandRedirect = hasWholeArgument && _subCommandMap.containsKey(arguments[0]);

        if(isSubCommandRedirect){
            Command command = getSubCommand(arguments[0]);
            return command.onTabComplete(sender, bukkitCommand, label, Arrays.copyOfRange(arguments, 1, arguments.length));
        }

        boolean isFirstArgument = arguments.length == 1;
        List<String> suggestions = new ArrayList<>();
        List<String> previousArguments = Arrays.asList(Arrays.copyOfRange(arguments, 0, arguments.length - 1));
        String currentArgument = arguments[arguments.length - 1];

        if(isFirstArgument)
            suggestions.addAll(_subCommandMap.keySet());

        suggestions.addAll(_argumentConverter.completeArgument(sender, arguments));

        suggestions = onTabSuggest(sender, previousArguments, currentArgument, suggestions);

        suggestions.removeIf(string -> !string.toLowerCase().startsWith(currentArgument.toLowerCase()));
        Collections.sort(suggestions);

        return suggestions;
    }

    /**
     * Sets the {@link ArgumentConverter}.
     * @param converter The {@link ArgumentConverter} to be set.
     * @see OrderedArgumentConverter
     */
    protected void setArgumentConverter(ArgumentConverter converter){
        _argumentConverter = converter;
    }

    /**
     * Returns the current {@link ArgumentConverter}.
     * @return the current {@link ArgumentConverter}.
     */
    protected ArgumentConverter getArgumentConverter(){
        return _argumentConverter;
    }

    /**
     * Returns true if the command is limited to a specific {@link SenderType} (any SenderType but {@link SenderType#ANY}).
     * @return true if the command is limited to a specific {@link SenderType} (any SenderType but {@link SenderType#ANY}).
     */
    protected boolean hasRequiredSenderType(){
        return !getRequiredSenderType().equals(SenderType.ANY);
    }

    /**
     * Limits the command to a specified {@link SenderType}. Use {@link SenderType#ANY} for no {@link SenderType} limitations.
     * @param type The type the command is limited to. Or {@link SenderType#ANY} for no limitations.
     */
    protected void setRequiredSenderType(SenderType type){
        _requiredSenderType = type == null ? SenderType.ANY : type;
    }

    /**
     * Returns the required {@link SenderType} for this command, or null if none.
     * @return the required {@link SenderType} for this command, or null if none.
     */
    protected SenderType getRequiredSenderType(){
        return _requiredSenderType == null ? SenderType.ANY : _requiredSenderType;
    }

    /**
     * Returns true if the command has a parent command.
     * @return true if the command has a parent command.
     */
    protected boolean hasParent(){
        return _parent != null;
    }

    /**
     * Returns the parent of this command, or null if none.
     * @return the parent of this command, or null if none.
     */
    protected Command getParent(){
        return _parent;
    }

    /**
     * Adds a sub-command to the current command.
     * @param label The sub-command label. E.g. "give" in the theoretical "economy give" command.
     * @param command The sub-command to be set.
     */
    protected void addSubCommand(String label, Command command){
        PluginCommand pluginCommand = Bukkit.getPluginCommand(getLabel() + " " + label);

        if(pluginCommand != null)
            pluginCommand.setExecutor(command);

        _subCommandMap.put(label, command);
    }

    protected Command getSubCommand(String label){
        return _subCommandMap.get(label);
    }
}
